/* automatically generated by rust-bindgen */
extern crate libc;
use libc::{gid_t, uid_t};

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct munge_ctx {
    _unused: [u8; 0],
}
#[doc = "  Data Types"]
pub type munge_ctx_t = *mut munge_ctx;
pub const MUNGE_OPT_CIPHER_TYPE: munge_opt = 0;
pub const MUNGE_OPT_MAC_TYPE: munge_opt = 1;
pub const MUNGE_OPT_ZIP_TYPE: munge_opt = 2;
pub const MUNGE_OPT_REALM: munge_opt = 3;
pub const MUNGE_OPT_TTL: munge_opt = 4;
pub const MUNGE_OPT_ADDR4: munge_opt = 5;
pub const MUNGE_OPT_ENCODE_TIME: munge_opt = 6;
pub const MUNGE_OPT_DECODE_TIME: munge_opt = 7;
pub const MUNGE_OPT_SOCKET: munge_opt = 8;
pub const MUNGE_OPT_UID_RESTRICTION: munge_opt = 9;
pub const MUNGE_OPT_GID_RESTRICTION: munge_opt = 10;
pub type munge_opt = u32;
pub use self::munge_opt as munge_opt_t;
pub const MUNGE_ENUM_CIPHER: munge_enum = 0;
pub const MUNGE_ENUM_MAC: munge_enum = 1;
pub const MUNGE_ENUM_ZIP: munge_enum = 2;
pub type munge_enum = u32;
pub use self::munge_enum as munge_enum_t;
pub const MUNGE_SUCCESS: munge_err = 0;
pub const MUNGE_SNAFU: munge_err = 1;
pub const MUNGE_BAD_ARG: munge_err = 2;
pub const MUNGE_BAD_LENGTH: munge_err = 3;
pub const MUNGE_OVERFLOW: munge_err = 4;
pub const MUNGE_NO_MEMORY: munge_err = 5;
pub const MUNGE_SOCKET: munge_err = 6;
pub const MUNGE_TIMEOUT: munge_err = 7;
pub const MUNGE_BAD_CRED: munge_err = 8;
pub const MUNGE_BAD_VERSION: munge_err = 9;
pub const MUNGE_BAD_CIPHER: munge_err = 10;
pub const MUNGE_BAD_MAC: munge_err = 11;
pub const MUNGE_BAD_ZIP: munge_err = 12;
pub const MUNGE_BAD_REALM: munge_err = 13;
pub const MUNGE_CRED_INVALID: munge_err = 14;
pub const MUNGE_CRED_EXPIRED: munge_err = 15;
pub const MUNGE_CRED_REWOUND: munge_err = 16;
pub const MUNGE_CRED_REPLAYED: munge_err = 17;
pub const MUNGE_CRED_UNAUTHORIZED: munge_err = 18;
pub type munge_err = u32;
pub use self::munge_err as munge_err_t;

extern "C" {
    #[doc = "  Primary Functions"]
    pub fn munge_encode(
        cred: *mut *mut ::std::os::raw::c_char,
        ctx: munge_ctx_t,
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> munge_err_t;

    pub fn munge_decode(
        cred: *const ::std::os::raw::c_char,
        ctx: munge_ctx_t,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        uid: *mut uid_t,
        gid: *mut gid_t,
    ) -> munge_err_t;

    #[doc = "  Context Functions"]
    #[doc = ""]
    #[doc = "  The context passed to munge_encode() is treated read-only except for the"]
    #[doc = "    error message that is set when an error is returned."]
    #[doc = "  The context passed to munge_decode() is set according to the context used"]
    #[doc = "    to encode the credential; however, on error, its settings may be in a"]
    #[doc = "    state which is invalid for encoding."]
    #[doc = "  Consequently, separate contexts should be used for encoding and decoding."]
    #[doc = "  A context should not be shared between threads unless it is protected by"]
    #[doc = "    a mutex; however, a better alternative is to use a separate context"]
    #[doc = "    (or two) for each thread, either by creating a new one or copying an"]
    #[doc = "    existing one."]
    pub fn munge_ctx_create() -> munge_ctx_t;

    pub fn munge_ctx_copy(ctx: munge_ctx_t) -> munge_ctx_t;

    pub fn munge_ctx_destroy(ctx: munge_ctx_t);

    pub fn munge_strerror(ctx: munge_err_t) -> *const libc::c_char;

    pub fn munge_ctx_get(ctx: munge_ctx_t, opt: munge_opt_t, ...) -> munge_err_t;

    pub fn munge_ctx_set(ctx: munge_ctx_t, opt: munge_opt_t, ...) -> munge_err_t;

    #[doc = "  Enumeration Functions"]
    pub fn munge_enum_is_valid(
        type_: munge_enum_t,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn munge_enum_int_to_str(
        type_: munge_enum_t,
        val: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;

    pub fn munge_enum_str_to_int(
        type_: munge_enum_t,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
